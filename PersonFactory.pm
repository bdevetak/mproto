package PersonFactory;

use strict;
use warnings;

BEGIN {
    eval {
        package Person;
        use Moose;
        1;
    }    
}

use Person;
use Data::Structure::Util qw(unbless);
use Google::ProtocolBuffers::Dynamic;

use constant PRODUCES_TYPE => "Person";
use constant PROTO_PACKAGE => "Messages";

sub _get_proto_schema {
    my $schema = <<PROTO
syntax = "proto2";

package humans;

message Person{
    required string name = 1;
    required int32 id = 2;
    optional string email = 3;
}
PROTO
    return  $schema;
}

# This is if we allready have a Moose class    
sub new {

    my $CLASS_NAME = PRODUCES_TYPE;

    my $proto_message_name = lc($CLASS_NAME) . "proto";

    my $proto_schema = _extract_proto_schema_from_moose_class({
        moose_class   => $CLASS_NAME,
        proto_package => PROTO_PACKAGE, 
    });

    my $dynamic = Google::ProtocolBuffers::Dynamic->new();

    $dynamic->load_string(
        $proto_message_name,
        $proto_schema
    );

    $dynamic->map({
        package => 'messages', prefix => ucfirst('messages')
    });

    return bless {
        description      => "Factory for Moose class Person",
        dynamic          => $dynamic,
        moose_class      => "Person",
        proto_package    => PROTO_PACKAGE,
        proto_schema     => $proto_schema, 
    };    
}

# this is if we have a proto schema. In this case this will
# return a factory that can generate Moose objects from that
# schema and econde tham back to protobuf with that schema
sub new_factory_from_proto {

    my $CLASS_NAME = PRODUCES_TYPE;

    my $proto_message_name = lc($CLASS_NAME) . "proto";

    my $proto_schema = _get_proto_schema();

    my $dynamic = Google::ProtocolBuffers::Dynamic->new();

    $dynamic->load_string(
        $proto_message_name,
        $proto_schema
    );

    $dynamic->map({
        package => 'messages', prefix => ucfirst('messages')
    });

    _setup_moose_class_attributes_from_proto_schema('Person', $proto_schema);

    return bless {
        description      => "Factory for Moose class Person",
        dynamic          => $dynamic,
        moose_class      => "Person",
        proto_package    => PROTO_PACKAGE,
        proto_schema     => $proto_schema, 
    };    
}

# serialize Person object to protobuf message
sub moose_to_proto {
    my $self = shift; 
}

# create Person from protobuf message
sub moose_from_proto {
        my $self = shift;
    my $protobuf_message = shift;

    my $class = 'Messages::' . $self->{moose_class};

    # All messages go to the package Messages::* by convention
    # The way serializer works, it generates perl classes automatically
    # from protobuf messages. What this factory does, is it creates
    # a wrapper around serializer and then creates Moose object from
    # blessed hash generated by the serializer. So, two objects are
    # generated based on the protobuf message. The first object generated
    # by the serializer is the message object which is a standard blessed
    # hashref. The second is Moose object created from the message. The
    # types in the proto schema correspond to the Moose attribute types.
    my $personMessage = $class->decode($protobuf_message);

    # extract params from protobuf message
    # TODO: loop all parameters required by Moose class and make sure they
    #       are there.
    my @params = (
        name  => $personMessage->{name},
        id    => $personMessage->{id},
    );

    # create Moose object
    my $personObject = Person->new(@params);

    return $personObject;    
}

sub moose_to_proto {
    my $self         = shift; # Factory object
    my $moose_object = shift; # Moose object

    my $hash = unbless $moose_object;

    my $bytes = $self->hash_to_proto($hash)
}

sub hash_to_proto {
    my $self = shift; # Factory object
    my $hash = shift;
    
    my $class = 'Messages::' . $self->{moose_class};

    my $proto_object = $class->new($hash); 
    my $bytes  = $class->encode($proto_object);
    return $bytes;
}

# proto_schema
sub _extract_proto_schema_from_moose_class {

    my $params = shift;

    my $moose_class   = $params->{moose_class};
    my $proto_package = $params->{proto_package};

    my $proto = q|
syntax = "proto2";

package | . lc($proto_package) . q|;

message |;

    $proto .= $moose_class . " {\n";

    # array of Moose class attributes, sorted in the way they are in 
    # in the proto message
    my $moose_obj_attributes = _get_attribute_description();
  
    # TODO: this should be in some base class
    my %moose_type_to_proto_type = (
        Str => 'string',
        Int => 'int32',
    );

    for my $att (@$moose_obj_attributes) {
        $proto .= "\t";
        $proto .= ($att->{required} ? "required" : "optional");
        $proto .= " ";
        $proto .= $moose_type_to_proto_type{$att->{type}};
        $proto .= " ";
        $proto .= $att->{name};
        $proto .= " = ";
        $proto .= $att->{proto_id};
        $proto .= ";\n";

    }

    $proto .= "}\n";
    return $proto;
}

# Factory class method: proto ids map is the same for all instances
sub _attribute_name_to_proto_id_map {
    return {
        name  => 1,
        id    => 2,
        email => 3, 
    } 
}

sub _get_attribute_description {
    my $CLASS_NAME = PRODUCES_TYPE;
    my $meta = $CLASS_NAME->meta;
    my @att;
    for my $att ($meta->get_all_attributes) {
        push @att, {
            name     => $att->{name}    ,
            type     => $att->{isa}     ,
            required => $att->{required},
            proto_id => _attribute_name_to_proto_id_map()->{$att->{name}},
        };
    }
 
    return \@att;
}

sub _setup_moose_class_attributes_from_proto_message {
    my $message_name = shift;
    my $proto_schema = shift;

    
    my $moose_class = $self->{moose_class};
    my $meta = $moose_class->meta;

    $meta->add_attribute(name => (
        is => 'ro',
        isa => 'Str',
        required => 1,
    ));

    $meta->add_attribute(id => (
        is => 'ro',
        isa => 'Int',
        required => 1,
    ));

    $meta->add_attribute(email => (
        is => 'rw',
        isa => 'Str',
        required => 0,
    ));
}

1;
